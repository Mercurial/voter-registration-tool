{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell #-}

module Config (Config(Config), opts, mkConfig) where

import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import Control.Monad.IO.Class (MonadIO, liftIO)
import Control.Monad.Except (MonadError, ExceptT, throwError, catchError)
import Control.Lens ((#))
import Control.Lens.TH
import Control.Exception.Safe (try)

import Options.Applicative

import Cardano.CLI.Environment ( EnvSocketError, readEnvSocketPath)
import qualified Cardano.API as Api
import Cardano.API (Address, SigningKey, StakeKey, Witness, NetworkId, FileError, PaymentKey, Bech32DecodeError)
import Cardano.Api.Typed (Shelley, TTL, SlotNo(SlotNo))
import Cardano.CLI.Shelley.Key (InputDecodeError)
import Cardano.CLI.Shelley.Commands (WitnessFile(WitnessFile))
import Cardano.CLI.Types (SigningKeyFile (..), SocketPath)
import Cardano.Api.TextView (TextViewError)

import Cardano.API.Extended (AsInputDecodeError(_InputDecodeError), AsFileError(__FileError, _FileIOError), readSigningKeyFile, readerFromAttoParser, parseAddress, pNetworkId, AsBech32DecodeError(_Bech32DecodeError), VotingKeyPublic, deserialiseFromBech32, AsType(AsVotingKeyPublic))
import Cardano.CLI.Voting.Error (AsTextViewError(_TextViewError))

data Config
  = Config { cfgPaymentAddress    :: Address Shelley
           , cfgStakeSigningKey   :: SigningKey StakeKey
           , cfgPaymentSigningKey :: SigningKey PaymentKey
           , cfgVotePublicKey     :: VotingKeyPublic
           , cfgNetworkId         :: NetworkId
           , cfgTTL               :: TTL
           }
  deriving (Show)

data FileErrors = FileErrorInputDecode InputDecodeError
                | FileErrorTextView TextViewError
  deriving (Show)

makePrisms ''FileErrors

instance AsInputDecodeError FileErrors where
  _InputDecodeError = _FileErrorInputDecode

instance AsTextViewError FileErrors where
  _TextViewError = _FileErrorTextView

data ConfigError
  = ConfigFailedToReadFile (Api.FileError FileErrors)
  | ConfigFailedToDecodeBech32 Bech32DecodeError
  deriving (Show)

makePrisms ''ConfigError

instance AsFileError ConfigError FileErrors where
  __FileError = _ConfigFailedToReadFile

instance AsBech32DecodeError ConfigError where
  _Bech32DecodeError = _ConfigFailedToDecodeBech32
  
mkConfig
  :: Opts
  -> ExceptT ConfigError IO Config
mkConfig (Opts stateDir pskf addr vpkf sskf networkId ttl) = do
  stkSign <- readSigningKeyFile Api.AsStakeKey   (SigningKeyFile sskf)
  paySign <- readSigningKeyFile Api.AsPaymentKey (SigningKeyFile pskf)
  votepk  <- readVotePublicKey vpkf

  pure $ Config addr stkSign paySign votepk networkId ttl

data Opts
  = Opts { optStateDir              :: FilePath
         , optPaymentSigningKeyFile :: FilePath
         , optPaymentAddress        :: Address Shelley
         , optVotePublicKeyFile     :: FilePath
         , optStakeSigningKeyFile   :: FilePath
         , optNetworkId             :: NetworkId
         , optTTL                   :: TTL
         }
  deriving (Eq, Show)

parseOpts :: Parser Opts
parseOpts = Opts
  <$> strOption (long "state-dir" <> metavar "DIR" <> help "state directory" <> showDefault <> value "./state-node-testnet")
  <*> strOption (long "payment-signing-key" <> metavar "FILE" <> help "file used to sign transaction")
  <*> option (readerFromAttoParser parseAddress) (long "payment-address" <> metavar "STRING" <> help "address associated with payment (hard-coded to use info from first utxo of address)")
  <*> strOption (long "vote-public-key" <> metavar "FILE" <> help "vote key generated by jcli (corresponding private key must be ed25519extended)")
  <*> strOption (long "stake-signing-key" <> metavar "FILE" <> help "stake authorizing vote key")
  <*> pNetworkId
  <*> pTTL

opts =
  info
    ( parseOpts <**> helper )
    ( fullDesc
    <> progDesc "Create a vote transaction"
    <> header "voter-registration - a tool to create vote transactions"
    )

pTTL :: Parser (TTL)
pTTL = SlotNo
    <$> option auto
          ( long "time-to-live"
          <> metavar "WORD64"
          <> help "The number of slots from the current slot at which the vote transaction times out."
          <> showDefault <> value 5000
          )

stripTrailingNewlines :: Text -> Text
stripTrailingNewlines = T.intercalate "\n" . filter (not . T.null) . T.lines

readVotePublicKey
  :: ( MonadIO m
     , MonadError e m
     , AsFileError e d
     , AsBech32DecodeError e
     )
  => FilePath
  -> m VotingKeyPublic
readVotePublicKey path = do
  result <- liftIO . try $ TIO.readFile path
  raw    <- either (\e -> throwError . (_FileIOError #) $ (path, e)) pure result
  let publicKeyBech32 = stripTrailingNewlines raw
  either (throwError . (_Bech32DecodeError #)) pure $ deserialiseFromBech32 AsVotingKeyPublic publicKeyBech32
